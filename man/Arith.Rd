% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FLArray.R, R/FLPar.R
\docType{methods}
\name{Arith}
\alias{Arith}
\alias{Arith,FLArray,FLArray-method}
\alias{Arith,FLArray,FLPar-method}
\alias{Arith,FLArray,numeric-method}
\alias{Arith,FLPar,FLArray-method}
\alias{Arith,FLPar,FLPar-method}
\alias{Arith,numeric,FLArray-method}
\title{Method Arith}
\usage{
\S4method{Arith}{numeric,FLArray}(e1, e2)

\S4method{Arith}{FLArray,numeric}(e1, e2)

\S4method{Arith}{FLArray,FLArray}(e1, e2)

\S4method{Arith}{FLPar,FLPar}(e1, e2)

\S4method{Arith}{FLArray,FLPar}(e1, e2)

\S4method{Arith}{FLPar,FLArray}(e1, e2)
}
\arguments{
\item{e1, e2}{Objects}
}
\description{
Arithmetic methods for FLR objects
}
\details{
The \code{Arith} group of methods, comprising addition, substraction,
product, division, exponentiation, modulus and integer division ().
These methods work exactly as in an object of class \code{array}, but always
return an \code{FLQuant} object, thus no dimension is dropped.

Operations between an \code{FLQuant} and an \code{FLPar} object will always
return an FLQuant, with the \code{FLPar} dimensions being place on top of
the correspoding ones at the \code{FLQuant} object. See examples below.
}
\section{Generic function}{
 Arith(e1,e2)
}
\examples{

flq <- FLQuant(c(9,5), dim=c(2,5))
fl2 <- FLQuant(2, dim=c(2,5))
flq * fl2
flq / fl2

# FLQuant against numeric vector
flq * 2.5
# Recycling rule applies
flq * c(1, 2)


# FLQuant and FLPar
flq * FLPar(a=3)

# Operations are made to match dimension names
flp <- FLPar(1/(1:5), dimnames=list(params='a', year=1:5, iter=1), units='NA')
flq * flp

}
\author{
The FLR Team
}
\seealso{
\code{\link[base]{Arithmetic}}, \code{\link[methods]{Arith}}
}
\keyword{methods}

